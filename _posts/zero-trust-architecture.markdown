---
title: "Zero Trust Architecture"
date: 2022-03-04T11:31:21+01:00
draft: true
---
# Let's talk about trust - best practices building a zero trust architecture

Software is eating the world (Marc Andreessen)! Many traditional companies are facing the distruption of their business model. To stay relevant they need to find ways to digitalize their business model. They need to rethink the way they create and deliver software to keep up with the speed of innovation of new market entrants. The same is true for dealing with security. Many traditional companies have a central team dealing with all security related issues. Such a team does not scale well (warum?). (argumentationssprung, erst das warum beschreiben, dann einen überblick geben was man in diesem blogeintrag zu erwarten hat) The responsibility to create and release secure applictions should be job zero (cite AWS) for every software development team. Employing a Zero Trust Architecture model to be used alongside a microservice architecture is empowering teams to do just that.   

Many companies today are securing their workloads by dividing their network infrastructure in trusted zones and untrusted zones. Within a trusted zone each application can call each other application without any further security measures. Trusted zones are protected by firewalls blocking all traffic that is not whitelisted. The weak point of such a security concept is the protection of its perimeter. A malicious client having access to the trusted network is posing a severe threat for all workloads within that network zone. Thus, changes to the perimeter infrastructure need to be reviewed thoroughly which can be a time consuming process. In the same way all changes to workloads within a trusted network zone need to be reviewed by (ist eigentlich egal durch wen, es ist nur wichtig dass das review stattfindet) the security team. Each change might introduce a vulnerability that can be exploitet by malicious clients. Thus, the risk of having a compromised trusted network is getting higher with the number of changes applied to the network itself and the workloads residing within that network. (überleitung zu shift left on security, empower dev teams to securing their workloads, this scales because responsibility for security is given to dev teams, at aws many tools are there to scan security vulnerabilities in a preventetive way)

## Zero Trust Model
The concept to overcome these security related challenges (which ones?) is to go away from having a trusted network zones model to a so called zero trust model. Applying this model companies abandon the concept of a trusted network zone. All applications residing within the network of a company are considered compromised leading to a zero trust relationship between applications. In such an environment every message received by a workload needs to be authenticated and authorized by that workload in order to be processed. This means on one hand that each microservice needs to implement its own authentication and authorization mechanism. The responsibility securing their workloads is given from the central security team to the respective microservice development teams. On the other hand every microservice development team is able to deploy changes as often as they want because they are empowered to manage all security related aspects for their respective microservices (leading to more authonomy empowering teams to take fast decisions)

In a zero trust environment the following to conditions need to be true in order to allow a microservice to process an incoming message. 

1. Technical level (system-to-system): The respective client application is authorized to send messages to the microservice
2. Actor level: A human or technical actor is authorized to invoke the microservice 

The best practice implementing condition 1 is to use mutual TLS (mTLS) (here we need to differentiate between requests coming from the outside or inside. outside: mtls often is not required). Using mTLS a client application can prove its identity to the microservice it is calling and vice versa. The goal of using TLS  in the internet is to create an encrypted end-to-end communication channel between client and server. Setting up this channel the server needs to prove its identity to the client. mTLS is extending TLS by requiring also the client to prove its identity to the server. The result of the mTLS setup is an encrypted connection where client and server can be sure that they are who they claim to be. 

One way implementing condition 2 is to use a JSON Web Token (JWT). A JWT can be attached to each message a human user or technical user is sending. A JWT is a JSON object (rfc https://datatracker.ietf.org/doc/html/rfc9068) carrying all information necessary to authenticate the respective actor. It is signed with the private key of the OIDC server issuing the JWT so that the client can detect changes in the token by verifying the signature with the servers public key. In that way each third party the token is sent to can verify the signature.   

 zeigen welche arten von angriffen vermieden werden können. Die Verwendung von mTLS verhindert Angriffe bei denen ein gestohlener JWT verwendet werden kann, um unerlaubt APIs aufzurufen. Die verwendung von JWTs stellt sicher, dass aufrufe nur im namen berechtigter aktoren getätigt werden können

There are tools available to help developers dealing with the additional burden of having to authenticate and authorize every incoming request for every microservice. One of these tools is Istio [Istio](https://istio.io). With Istio developers create a so called Service Mesh running on Kubernetes. An Istio Service Mesh consists of an control plane and a set of side-cars that are deployed next to every microservice. Please refer to [](https://istio.io/latest/about/service-mesh/) for more details. The side-cars are responsible for managing all authentication and authorization related functionality. Services can only communicate to other services using the side-cars. There is no need to change the code of every microservice to deal with the authentication and authorization of incoming requests. 

Istio side-cars enforce two kinds of authentication policies. Peer authentication policies define whether two microservices communicating with each other need to authenticate using mutual TLS. Request authentication policies define how requests are authenticated on a technical level. The most common approach for Istio is to use JSON Web Tokens. 